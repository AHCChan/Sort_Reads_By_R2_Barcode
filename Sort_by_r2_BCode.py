HELP_DOC = """
SORT READS BY R2 BARCODE
(version 1.0)
by Angelo Chan

This is a program for sorting next-gen sequencing reads (FASTQ format) into one
of three pairs of output files, based on the presence, absence, or partial
presence, of a specified barcode at the start of the R2 reads.

Users may specify the mismatch threshold at which a read is considered to have a
complete match, or a partial match.

If the output file names are not specified by the user, output file names will
be automatically generated by the program.



USAGE:
    
    python27 Sort_by_r2_BCode.py <input_path_r1> <input_path_r2> <barcode>
            [-o <p1> <p2> <p3> <p4> <p5> <p6>] [-t <threshold_match>
            <threshold_partial>]



MANDATORY:
    
    input_path_r1
        
        The filepath of the input r1 file.
    
    input_path_r2
        
        The filepath of the input r2 file.
    
    barcode
        
        The nucleotide sequence being looked for in the r2 file.
        Ambiguous nucleotides accepted.OPTIONAL:

OPTIONAL:

    p1
        
        (DEFAULT path generation available)
        
        The filepath of the output file, for r1 reads, of pairs where the start
        of the r2 read contained a match for the barcode.

    p2
        
        (DEFAULT path generation available)
        
        The filepath of the output file, for r2 reads, of pairs where the start
        of the r2 read contained a match for the barcode.

    p3
        
        (DEFAULT path generation available)
        
        The filepath of the output file, for r1 reads, of pairs where the start
        of the r2 read contained a partial match for the barcode.

    p4
        
        (DEFAULT path generation available)
        
        The filepath of the output file, for r2 reads, of pairs where the start
        of the r2 read contained a partial match for the barcode.

    p5
        
        (DEFAULT path generation available)
        
        The filepath of the output file, for r1 reads, of pairs where the start
        of the r2 read did not contain a match for the barcode.

    p6
        
        (DEFAULT path generation available)
        
        The filepath of the output file, for r2 reads, of pairs where the start
        of the r2 read did not contain a match for the barcode.

    threshold_match
        
        (DEFAULT: 0)
        
        The maximum permissible number of mismatches, between the barcode and
        the first nucleotides of the r2 read, for a read pair to be considered
        as containing a match.

    threshold_partial
        
        (DEFAULT: 0)
        
        The maximum permissible number of mismatches, between the barcode and
        the first nucleotides of the r2 read, for a read pair to be considered
        as containing a partial match.
        
        If this is set to the same value as the threshold for a complete match,
        a pair of output files for partial matches will still be generated, but
        they will be empty.

EXAMPLES EXPLANATION:
    
    1:
    Bare minimum use case. Only the mandatory inputs were supplied. Default
    settings were used where possible.
    
    2:
    More advanced use case with more options specified.

EXAMPLES:

    python27 Sort_by_r2_BCode.py reads_r1.fq reads_r2.fq CGTGAT

    python27 Sort_by_r2_BCode.py reads_r1.fq reads_r2.fq CGTGAT -o
            reads_match_r1.fq reads_match_r2.fq reads_partial_r1.fq
            reads_partial_r2.fq reads_absent_r1.fq reads_absent_r2.fq -t 1 2

USAGE:
    
    python27 Sort_by_r2_BCode.py <input_path_r1> <input_path_r2> <barcode>
            [-o <p1> <p2> <p3> <p4> <p5> <p6>] [-t <threshold_match>
            <threshold_partial>]
"""



# Configurations ###############################################################

AUTORUN = True

WRITE_PREVENT = False # Completely prevent overwritting existing files
WRITE_CONFIRM = True # Check to confirm overwritting existing files

PRINT_ERRORS = True
PRINT_PROGRESS = True
PRINT_METRICS = True



# Defaults #####################################################################

DEFAULT__threshold_match = 0
DEFAULT__threshold_partial = 0



# Imported Modules #############################################################

import sys



# Enums ########################################################################



# Strings ######################################################################

STR__use_help = "\nUse the -h option for help:\n\t "\
        "python Sort_by_r2_BCode.py -h"

STR__no_inputs = "\nERROR: No inputs were given."
STR__insufficient_inputs = "\nERROR: Not enough inputs were given."

STR__IO_error_read = "\nERROR: Input file \"{f}\" does not exist or could not "\
        "be opened."
STR__IO_error_write_forbid = """
ERROR: You specified an output file which already exists and the administrator
for this program has forbidden all overwrites. Please specify a different
output file, move the currently existing file, or configure the default options
in t2t.py."""
STR__IO_error_write_unable = """
ERROR: Unable to write to the specified output file "{F}\""""

STR__specify_6_arguments_for_outputs = """
ERROR: Please input 6 filepaths if you wish to specify output filepaths of your
choosing. Alternatively, you may use the default filepaths generated by this
program."""
STR__specify_2_arguments_for_thresholds = """
ERROR: Please input 2 arguments if you wish to specify cutoff thresholds for the
maximum permissible number of mismatches before a read pair is no longer
regarded as containing a perfect/partial match.
(DEFAULTS: {t1}, {t2}""".format(
        t1 = DEFAULT__threshold_match,
        t2 = DEFAULT__threshold_partial)

STR__invalid_threshold = "\nERROR: Please specify a non-negative integer."



STR__metrics_pairs =  "\nTotal Pairs:    {S}"
STR__metrics_matches =  "Total Matches:  {S} ( {P}% )"
STR__metrics_partials = "Total Partials: {S} ( {P}% )"
STR__metrics_absents =  "Total Absents:  {S} ( {P}% )"

STR__parsing_args = "\nParsing arguments..."

STR__sort_by_r2_bcode_begin = "\nRunning Sort_by_r2_BCode..."

STR__sort_by_r2_bcode_complete = "\nSorting successfully finished."



# Lists ########################################################################

LIST__help = ["-h", "-H", "-help", "-Help", "-HELP"]



# Dictionaries #################################################################



# File Processing Code #########################################################

def Sort_By_R2_Barcode(paths_in, paths_out, barcode, thresholds):
    """
    Function which performs the FASTQ file sorting.
    
    @paths_in
            (list<str - filepath>[2])
            The filepaths of the r1 and r2 input files. 
    @paths_out
            (list<str - filepath>[6])
            The filepaths for the output files, in the following order:
                r1 reads of read pairs with a complete barcode
                r2 reads of read pairs with a complete barcode
                r1 reads of read pairs with a partial barcode
                r2 reads of read pairs with a partial barcode
                r1 reads of read pairs with no barcode
                r2 reads of read pairs with no barcode
    @barcode
            (str)
            The DNA sequence being looked for in the r2 reads.
    @thresholds
            (list<int>[2])
            The maximum permissible number of mismatches for an r2 read to be
            considered as containing a complete barcode, and the maximum
            permissible number of mismatches for an r2 read to be considered as
            containing a partial barcode.
    
    Return a value of 0 if the function runs successfully.
    
    Sort_By_R2_Barcode([str, str], [str, str, str, str, str, str], str, [int,
            int]) -> int
    """
    printP(STR__sort_by_r2_bcode_begin)
    
    # Exit
    printP(STR__sort_by_r2_bcode_complete)
    return 0



# Command Line Parsing #########################################################

def Parse_Command_Line_Input__Sort_By_R2_BCode(raw_command_line_input):
    """
    Parse the command line input and call the Table_To_Table function with
    appropriate arguments if the command line input is valid.
    """
    printP(STR__parsing_args)
    # Run program
    Sort_By_R2_Barcode([], [], [] ,[])
    
    # Safe exit
    return 0



def Validate_Read_Path(filepath):
    """
    Validates the filepath of the input file.
    Return 0 if the filepath is valid.
    Return 1 otherwise.
    
    Validate_Read_Path(str) -> int
    """
    try:
        f = open(filepath, "U")
        f.close()
        return 0
    except:
        return 1


    
def Validate_Write_Path(filepath):
    """
    Validates the filepath of the input file.
    Return 0 if the filepath is writtable.
    Return 1 if the user decides to overwrite an existing file.
    Return 2 if the user declines to overwrite an existing file.
    Return 3 if the file exists and the program is set to forbid overwriting.
    Return 4 if the program is unable to write to the filepath specified.
    
    Validate_Write_Path(str) -> int
    """
    try:
        f = open(filepath, "U")
        f.close()
    except: # File does not exist. 
        try:
            f = open(filepath, "w")
            f.close()
            return 0 # File does not exist and it is possible to write
        except:
            return 4 # File does not exist but it is not possible to write
    # File exists
    if WRITE_PREVENT: return 3
    if WRITE_CONFIRM:
        confirm = raw_input(STR__overwrite_confirm)
        if confirm not in LIST__yes: return 2
    # User is not prevented from overwritting and may have chosen to overwrite
    try:
        f = open(filepath, "w")
        f.close()
        if WRITE_CONFIRM: return 1 # User has chosen to overwrite existing file
        return 0 # Overwriting existing file is possible
    except:
        return 4 # Unable to write to specified filepath



def Strip_X(string):
    """
    Strips leading and trailing inverted commans or brackets if a matching pair
    are flanking the string.
    
    Strip_X(str) -> str
    """
    if (    (string[0] == string[-1] == "\"") or
            (string[0] == string[-1] == "\'") or
            (string[0] == "(" and string[-1] == ")") or
            (string[0] == "{" and string[-1] == "}") or
            (string[0] == "[" and string[-1] == "]") or
            (string[0] == "<" and string[-1] == ">")
            ):
        return string[1:-1]
    return string



# Controlled Print Statements ##################################################

def printE(string):
    """
    A wrapper for the basic print statement.
    It is intended to be used for printing error messages.
    It can be controlled by a global variable.
    """
    if PRINT_ERRORS: print(string)

def printP(string):
    """
    A wrapper for the basic print statement.
    It is intended to be used for printing progress messages.
    It can be controlled by a global variable.
    """
    if PRINT_PROGRESS: print(string)

def printM(string):
    """
    A wrapper for the basic print statement.
    It is intended to be used for printing file metrics.
    It can be controlled by a global variable.
    """
    if PRINT_METRICS: print(string)



# Main Loop ####################################################################

if AUTORUN and (__name__ == "__main__"):
    exit_code = Parse_Command_Line_Input__Sort_By_R2_BCode(sys.argv)
